# N4SID state space model. Built using Sippy.

from pathlib import Path

from casadi.tools import *

sys.path.append('../')
import do_mpc


class ModelParameters:
    """This class will be instantiated in various models, so make sure that there are no
    data intensive operations in it."""

    def __init__(self):
        # Load in the N4SID matrices
        p = Path('.').resolve().parent / 'lasso_and_n4sid'
        if p.exists():
            # States are room temperatures, <to flesh out>
            self.a = np.load(p / 'matrix_A1.npy')
            self.b = np.load(p / 'matrix_B1.npy')
            self.c = np.load(p / 'matrix_C1.npy')
            self.d = np.load(p / 'matrix_D1.npy')

        print(f"A: {self.a.shape}")
        print(f"B: {self.b.shape}")
        print(f"C: {self.c.shape}")
        print(f"D: {self.d.shape}")

        # The x matrix is generated by Sippy, we don't know the meaning of the inputs.
        self.max_x = np.array([
            [4.0], [10.0], [4.0], [10.0], [4.0], [10.0], [4.0], [10.0]
        ])
        self.min_x = - self.max_x

        # state space u values
        # u[0]  = 'mod.building.weaBus.HDifHor'
        # u[1]  = 'mod.building.weaBus.HDirNor'
        # u[2]  = 'mod.building.weaBus.HGloHor'
        # u[3]  = 'mod.building.weaBus.HHorIR'
        # u[4]  = 'mod.building.weaBus.TBlaSky'
        # u[5]  = 'mod.building.weaBus.TDryBul'
        # u[6]  = 'mod.building.weaBus.TWetBul'
        # u[7]  = 'mod.building.weaBus.winSpe'
        # u[8]  = 'mod.building.weaBus.winDir'
        # u[9]  = 'mod.building.weaBus.relHum'
        # u[10] = 'mod.corZon.fmuZon.QCon_flow'
        # u[11] = 'mod.HVAC.hea.Q_flow'
        # u[12] = 'mod.HVAC.fan.P'
        # u[13] = 'mod.HVAC.volSenSup.V_flow'
        # u[14] = 'mod.HVAC.volSenOA.V_flow'
        # u[15] = 'mod.HVAC.senRelHum.phi'
        # u[16] = 'mod.HVAC.senTSup.T'
        # These are the variables that are needed to define the u matrix.
        # The order is
        self.variables = []
        self.variables.append({
            "type": "input",
            "var_name": "HDifHor",
            "min": 0,
            "max": 2000
        })
        self.variables.append({
            "type": "input",
            "var_name": "HDirNor",
            "min": 0,
            "max": 2000
        })
        self.max_u = np.array([
            [4.0], [4.0], [4.0], [4.0], [4.0], [4.0], [4.0], [4.0], [4.0], [4.0], [4.0], [4.0], [4.0], [4.0], [4.0],
            [4.0], [4.0]
        ])
        self.min_u = - self.max_u

        # running configuration
        self.time_step = 300
        self.n_horizon = 30

        # ------------------------------------------------------------
        # Example matrices
        # self.a = np.array([[0.763, 0.460, 0.115, 0.020],
        #               [-0.899, 0.763, 0.420, 0.115],
        #               [0.115, 0.020, 0.763, 0.460],
        #               [0.420, 0.115, -0.899, 0.763]])
        #
        # self.b = np.array([[0.014],
        #               [0.063],
        #               [0.221],
        #               [0.367]])
        #
        # # state space max x values
        # self.max_x = np.array([[4.0], [10.0], [4.0], [10.0]])
        # self.min_x = - self.max_x
        #
        # # state space max u values
        # self.min_u = -0.5
        # self.max_u = 0.5
        #
        # # running configuration
        # self.time_step = 300
        # self.n_horizon = 7


def template_model():
    model = do_mpc.model.Model('discrete')
    mp = ModelParameters()

    # States struct (optimization variables):
    # x's shape is the A's num of columns x 1
    _x = model.set_variable(var_type='_x', var_name='x', shape=(mp.a.shape[1], 1))

    # Input struct (optimization variables):
    # u's shape is B's num of columns x 1
    # _u = model.set_variable(var_type='_u', var_name='u', shape=(mp.b.shape[1], 1))
    hdirhor = model.set_variable(var_type='_tvp', var_name='HDifHor', shape=(1, 1))
    h2 = model.set_variable(var_type='_tvp', var_name='HDifHor_2', shape=(1, 1))
    h3 = model.set_variable(var_type='_u', var_name='HDifHor_3', shape=(1, 1))
    h4 = model.set_variable(var_type='_u', var_name='HDifHor_4', shape=(1, 1))
    h5 = model.set_variable(var_type='_u', var_name='HDifHor_5', shape=(1, 1))
    h6 = model.set_variable(var_type='_u', var_name='HDifHor_6', shape=(1, 1))
    h7 = model.set_variable(var_type='_u', var_name='HDifHor_7', shape=(1, 1))
    h8 = model.set_variable(var_type='_u', var_name='HDifHor_8', shape=(1, 1))
    h9 = model.set_variable(var_type='_u', var_name='HDifHor_9', shape=(1, 1))
    h10 = model.set_variable(var_type='_u', var_name='HDifHor_10', shape=(1, 1))
    h11 = model.set_variable(var_type='_u', var_name='HDifHor_11', shape=(1, 1))
    h12 = model.set_variable(var_type='_u', var_name='HDifHor_12', shape=(1, 1))
    h13 = model.set_variable(var_type='_u', var_name='HDifHor_13', shape=(1, 1))
    h14 = model.set_variable(var_type='_u', var_name='HDifHor_14', shape=(1, 1))
    h15 = model.set_variable(var_type='_u', var_name='HDifHor_15', shape=(1, 1))
    h16 = model.set_variable(var_type='_u', var_name='HDifHor_16', shape=(1, 1))
    h17 = model.set_variable(var_type='_u', var_name='HDifHor_17', shape=(1, 1))

    # Time-varying parameter for the MHE: Weighting of the measurements (tvp):
    # P_v = model.set_variable(var_type='_tvp', var_name='P_v', shape=(5, 5))

    # Set expression. These can be used in the cost function, as non-linear constraints
    # or just to monitor another output.

    # how do we make the cost function be a LASSO regression (or any other function?)
    # something like: model.set_expression(expr_name='cost', expr=sum1((_x[1] - _u[1]) ** 2))
    # need knowledge of the process variables:
    #    secondary variables on power consumption / demand.
    #    where are the constraints -- on y.

    model.set_expression(expr_name='cost', expr=sum1(_x ** 2))

    u_array = vertcat(
        hdirhor,
        h2,
        h3,
        h4,
        h5,
        h6,
        h7,
        h8,
        h9,
        h10,
        h11,
        h12,
        h13,
        h14,
        h15,
        h16,
        h17
    )
    x_next = mp.a @ _x + mp.b @ u_array
    model.set_rhs('x', x_next)

    # y_exp = mp.c @ _x + mp.d @ u_array
    # model.set_meas('y_meas', y_exp)

    model.setup()

    return model
